# Professional Summarizer Side Panel â€” Upgrade Guide
### Converting Popup to Conversational Side Panel with Google LLM

---

## What This Guide Does

Transforms your existing Chrome extension from:
- âŒ Small popup with single-shot summarization
- âŒ No conversation memory
- âŒ Basic UI

To:
- âœ… Full-height side panel with persistent state
- âœ… Conversation history with up to 3 follow-up questions per summary
- âœ… Professional, polished interface
- âœ… Google LLM integration (you've already done this)

---

## Architecture Changes

### Before (Popup)
```
User clicks icon â†’ Small popup (420px) â†’ Single request â†’ Result disappears when closed
```

### After (Side Panel)
```
User opens side panel â†’ Full browser height â†’ Persistent conversation â†’ Follow-ups allowed â†’ History saved per tab
```

### Key Technical Shifts

| Component | Before | After |
|---|---|---|
| UI Container | `action.default_popup` | `side_panel.default_path` |
| State Management | None (resets on close) | Session storage per tab |
| Conversation Flow | Single request | Thread with context (up to 3 follow-ups) |
| API Calls | Single `/summarize` | Initial + follow-up with history |
| UI Height | ~400px | Full browser height |

---

# Phase 1: Update Manifest for Side Panel

## Step 1: Replace manifest.json

**Action:** Replace `extension/manifest.json` entirely with:

```json
{
  "manifest_version": 3,
  "name": "Professional Summarizer",
  "version": "2.0",
  "description": "AI-powered summarization with conversational follow-ups",
  "permissions": [
    "activeTab",
    "sidePanel",
    "storage"
  ],
  "side_panel": {
    "default_path": "sidepanel.html"
  },
  "action": {
    "default_title": "Open Summarizer",
    "default_icon": {
      "16": "icons/icon16.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    }
  },
  "host_permissions": [
    "http://127.0.0.1:5000/*",
    "https://generativelanguage.googleapis.com/*"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  }
}
```

**Why each change matters:**

- **`sidePanel` permission**: Required to open side panel programmatically
- **`storage` permission**: Enables chrome.storage API for conversation persistence
- **`side_panel.default_path`**: Points to the new side panel HTML (not popup.html)
- **No `default_popup`**: Removes popup behavior entirely
- **`background.service_worker`**: Handles the click â†’ open side panel logic
- **Google API in `host_permissions`**: Your LLM calls need explicit permission

**Expected Result:** File saved. Extension reload will require new permissions.

**Common Failure:** Chrome shows "Permissions increased" warning.

**Fix:** This is expected. Click "Accept" when reloading the extension. Chrome requires explicit user consent when permissions expand.

---

## Step 2: Create Background Service Worker

**Action:** Create `extension/background.js`:

```javascript
// Open side panel when extension icon is clicked
chrome.action.onClicked.addListener((tab) => {
  chrome.sidePanel.open({ windowId: tab.windowId });
});
```

**Why:** Manifest V3 no longer allows popups to open side panels directly. The background service worker is the only component that can call `chrome.sidePanel.open()`. When the user clicks the extension icon, this listener fires and opens the side panel for that window.

**Expected Result:** File created.

**Common Failure:** None at this stage.

**Fix:** Not applicable.

---

# Phase 2: Build Professional Side Panel UI

## Design Direction

**Aesthetic:** Refined, professional summarization tool. Think editorial magazine meets modern SaaS interface.

**Key Design Decisions:**
- **Typography:** Newsreader for headings (editorial feel), Inter for body (clarity)
- **Color Palette:** Deep navy base (#0a1628) with warm accent (#ff6b35), soft neutrals
- **Layout:** Chat-style interface with clear message bubbles, subtle shadows
- **Motion:** Smooth slide-ins for new messages, gentle hover states
- **Details:** Gradient mesh background, custom scrollbar, status indicators

---

## Step 3: Create Side Panel HTML

**Action:** Create `extension/sidepanel.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Professional Summarizer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Newsreader:wght@600;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #0a1628;
      --bg-secondary: #152238;
      --bg-tertiary: #1e2d45;
      --accent: #ff6b35;
      --accent-hover: #ff8555;
      --text-primary: #f8f9fa;
      --text-secondary: #a8b2c1;
      --text-muted: #6b7785;
      --border: #2a3f5f;
      --success: #10b981;
      --error: #ef4444;
      --warning: #f59e0b;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #0a1628 0%, #1a2d4a 50%, #0d1b2e 100%);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      position: relative;
    }

    /* Animated background mesh */
    body::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(ellipse at 20% 30%, rgba(255, 107, 53, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 70%, rgba(16, 185, 129, 0.08) 0%, transparent 50%);
      animation: meshShift 20s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes meshShift {
      0%, 100% { opacity: 0.6; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.05); }
    }

    .container {
      position: relative;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    header {
      background: rgba(21, 34, 56, 0.8);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
      padding: 20px 24px;
      flex-shrink: 0;
    }

    h1 {
      font-family: 'Newsreader', Georgia, serif;
      font-size: 24px;
      font-weight: 700;
      letter-spacing: -0.02em;
      background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 8px;
    }

    .status-bar {
      display: flex;
      gap: 12px;
      align-items: center;
      font-size: 12px;
      color: var(--text-muted);
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
      animation: pulse 2s ease-in-out infinite;
    }

    .status-dot.active {
      background: var(--success);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Messages Container */
    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      scroll-behavior: smooth;
    }

    /* Custom scrollbar */
    .messages-container::-webkit-scrollbar {
      width: 6px;
    }

    .messages-container::-webkit-scrollbar-track {
      background: rgba(42, 63, 95, 0.3);
    }

    .messages-container::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 3px;
    }

    .messages-container::-webkit-scrollbar-thumb:hover {
      background: var(--accent-hover);
    }

    /* Empty State */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
      padding: 40px;
    }

    .empty-state-icon {
      font-size: 64px;
      margin-bottom: 24px;
      opacity: 0.3;
    }

    .empty-state h2 {
      font-family: 'Newsreader', serif;
      font-size: 22px;
      margin-bottom: 12px;
      color: var(--text-primary);
    }

    .empty-state p {
      color: var(--text-secondary);
      max-width: 320px;
      line-height: 1.6;
      margin-bottom: 24px;
    }

    /* Message Bubble */
    .message {
      margin-bottom: 20px;
      animation: slideIn 0.3s ease-out;
      opacity: 0;
      animation-fill-mode: forwards;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
    }

    .message-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }

    .message.user .message-icon {
      background: var(--accent);
    }

    .message.assistant .message-icon {
      background: var(--success);
    }

    .message.system .message-icon {
      background: var(--warning);
    }

    .message-content {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px 18px;
      line-height: 1.6;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .message.user .message-content {
      background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
      border-left: 3px solid var(--accent);
    }

    .message.assistant .message-content {
      background: var(--bg-secondary);
      border-left: 3px solid var(--success);
    }

    .message.error .message-content {
      background: rgba(239, 68, 68, 0.1);
      border-left: 3px solid var(--error);
      color: #fca5a5;
    }

    .message-label {
      font-weight: 600;
      color: var(--accent);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 8px;
      display: block;
    }

    .message.assistant .message-label {
      color: var(--success);
    }

    .summary-meta {
      display: flex;
      gap: 12px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
      font-size: 11px;
      color: var(--text-muted);
    }

    .meta-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    /* Input Area */
    .input-section {
      background: rgba(21, 34, 56, 0.9);
      backdrop-filter: blur(10px);
      border-top: 1px solid var(--border);
      padding: 20px 24px;
      flex-shrink: 0;
    }

    .quick-actions {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .quick-btn {
      padding: 8px 14px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .quick-btn:hover {
      background: var(--accent);
      color: var(--text-primary);
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .quick-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .input-wrapper {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    textarea {
      flex: 1;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      color: var(--text-primary);
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      resize: none;
      height: 48px;
      transition: all 0.2s;
    }

    textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.1);
    }

    textarea::placeholder {
      color: var(--text-muted);
    }

    .send-btn {
      padding: 12px 24px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: var(--text-primary);
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .send-btn:hover {
      background: var(--accent-hover);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
    }

    .send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* Follow-up counter */
    .follow-up-counter {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 8px;
      text-align: right;
    }

    .follow-up-counter.warning {
      color: var(--warning);
    }

    .follow-up-counter.limit {
      color: var(--error);
    }

    /* Loading state */
    .typing-indicator {
      display: flex;
      gap: 4px;
      padding: 12px;
    }

    .typing-dot {
      width: 8px;
      height: 8px;
      background: var(--text-muted);
      border-radius: 50%;
      animation: typing 1.4s infinite;
    }

    .typing-dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes typing {
      0%, 60%, 100% {
        transform: translateY(0);
        opacity: 0.4;
      }
      30% {
        transform: translateY(-10px);
        opacity: 1;
      }
    }

    /* Clear conversation button */
    .clear-btn {
      padding: 6px 12px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-muted);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .clear-btn:hover {
      background: var(--error);
      color: var(--text-primary);
      border-color: var(--error);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Professional Summarizer</h1>
      <div class="status-bar">
        <div class="status-indicator">
          <div class="status-dot" id="statusDot"></div>
          <span id="statusText">Checking connection...</span>
        </div>
        <button class="clear-btn" id="clearBtn">Clear Conversation</button>
      </div>
    </header>

    <div class="messages-container" id="messagesContainer">
      <div class="empty-state" id="emptyState">
        <div class="empty-state-icon">ğŸ“„</div>
        <h2>Ready to Summarize</h2>
        <p>Choose a quick action below or ask me to summarize the current page, YouTube video, or any text you provide.</p>
      </div>
    </div>

    <div class="input-section">
      <div class="quick-actions">
        <button class="quick-btn" id="btnPage">Summarize This Page</button>
        <button class="quick-btn" id="btnYoutube">Summarize Video</button>
      </div>
      <div class="input-wrapper">
        <textarea 
          id="userInput" 
          placeholder="Ask a follow-up question or paste text to summarize..."
          rows="1"
        ></textarea>
        <button class="send-btn" id="sendBtn">Send</button>
      </div>
      <div class="follow-up-counter" id="followUpCounter"></div>
    </div>
  </div>

  <script src="sidepanel.js"></script>
</body>
</html>
```

**Why this design works:**

**Typography:** Newsreader (serif) for headings creates editorial credibility. Inter for body ensures readability at small sizes.

**Color System:** Dark navy base with warm orange accent avoids the generic purple/blue schemes. Deep backgrounds reduce eye strain during extended use.

**Spatial Design:** Chat-style bubbles with distinct left borders differentiate user vs. assistant. Generous padding prevents cramped feeling.

**Motion:** Slide-in animations on new messages create a sense of progression. Subtle background mesh animation adds life without distraction.

**Professional Details:** Custom scrollbar, status indicators, follow-up counter, gradient text on title, backdrop blur on header/footer.

**Expected Result:** File created. UI will render when side panel opens.

---

## Step 4: Create Side Panel JavaScript Logic

**Action:** Create `extension/sidepanel.js`:

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Configuration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const API_BASE = 'http://127.0.0.1:5000';
const MAX_FOLLOW_UPS = 3;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// State Management
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let conversationState = {
  messages: [],
  followUpCount: 0,
  currentContext: null, // Stores the original summary for follow-ups
  isProcessing: false
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOM Elements
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const elements = {
  messagesContainer: document.getElementById('messagesContainer'),
  emptyState: document.getElementById('emptyState'),
  userInput: document.getElementById('userInput'),
  sendBtn: document.getElementById('sendBtn'),
  btnPage: document.getElementById('btnPage'),
  btnYoutube: document.getElementById('btnYoutube'),
  clearBtn: document.getElementById('clearBtn'),
  statusDot: document.getElementById('statusDot'),
  statusText: document.getElementById('statusText'),
  followUpCounter: document.getElementById('followUpCounter')
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Health Check
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function checkHealth() {
  try {
    const res = await fetch(`${API_BASE}/health`, { method: 'GET' });
    const data = await res.json();
    
    elements.statusDot.classList.add('active');
    elements.statusText.textContent = `Server ready (${data.model || 'Google LLM'})`;
  } catch {
    elements.statusDot.classList.remove('active');
    elements.statusText.textContent = 'Server offline';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI Helpers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function hideEmptyState() {
  elements.emptyState.style.display = 'none';
}

function addMessage(role, content, metadata = {}) {
  hideEmptyState();
  
  const message = document.createElement('div');
  message.className = `message ${role}`;
  
  const icon = role === 'user' ? 'ğŸ‘¤' : role === 'assistant' ? 'ğŸ¤–' : 'âš ï¸';
  const label = role === 'user' ? 'You' : role === 'assistant' ? 'Summary' : 'System';
  
  let metaHTML = '';
  if (metadata.source) {
    metaHTML = `
      <div class="summary-meta">
        <div class="meta-item">ğŸ“Œ ${metadata.source}</div>
        ${metadata.followUpCount !== undefined ? `<div class="meta-item">ğŸ’¬ ${metadata.followUpCount}/3 follow-ups</div>` : ''}
      </div>
    `;
  }
  
  message.innerHTML = `
    <div class="message-header">
      <div class="message-icon">${icon}</div>
      <span>${label}</span>
    </div>
    <div class="message-content">
      ${role === 'assistant' ? '<span class="message-label">Summary</span>' : ''}
      ${content}
      ${metaHTML}
    </div>
  `;
  
  elements.messagesContainer.appendChild(message);
  elements.messagesContainer.scrollTop = elements.messagesContainer.scrollHeight;
  
  conversationState.messages.push({ role, content, metadata });
}

function addTypingIndicator() {
  const indicator = document.createElement('div');
  indicator.className = 'message assistant';
  indicator.id = 'typingIndicator';
  indicator.innerHTML = `
    <div class="message-header">
      <div class="message-icon">ğŸ¤–</div>
      <span>AI is thinking...</span>
    </div>
    <div class="message-content">
      <div class="typing-indicator">
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
      </div>
    </div>
  `;
  elements.messagesContainer.appendChild(indicator);
  elements.messagesContainer.scrollTop = elements.messagesContainer.scrollHeight;
}

function removeTypingIndicator() {
  const indicator = document.getElementById('typingIndicator');
  if (indicator) indicator.remove();
}

function updateFollowUpCounter() {
  const remaining = MAX_FOLLOW_UPS - conversationState.followUpCount;
  
  if (!conversationState.currentContext) {
    elements.followUpCounter.textContent = '';
    elements.followUpCounter.className = 'follow-up-counter';
    return;
  }
  
  if (remaining > 0) {
    elements.followUpCounter.textContent = `${remaining} follow-up question${remaining !== 1 ? 's' : ''} remaining`;
    elements.followUpCounter.className = remaining === 1 ? 'follow-up-counter warning' : 'follow-up-counter';
  } else {
    elements.followUpCounter.textContent = 'Follow-up limit reached. Start a new summary to ask more questions.';
    elements.followUpCounter.className = 'follow-up-counter limit';
  }
}

function setProcessing(isProcessing) {
  conversationState.isProcessing = isProcessing;
  elements.sendBtn.disabled = isProcessing;
  elements.btnPage.disabled = isProcessing;
  elements.btnYoutube.disabled = isProcessing;
  elements.userInput.disabled = isProcessing;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API Calls
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function getCurrentUrl() {
  const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
  return tabs[0]?.url || '';
}

async function callAPI(endpoint, payload) {
  const res = await fetch(`${API_BASE}${endpoint}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  
  if (!res.ok) {
    const errorData = await res.json();
    throw new Error(errorData.error || `HTTP ${res.status}`);
  }
  
  return await res.json();
}

async function summarizePage(url) {
  setProcessing(true);
  addMessage('user', `Summarize: ${url}`, { source: 'Current Page' });
  addTypingIndicator();
  
  try {
    const isYouTube = url.includes('youtube.com') || url.includes('youtu.be');
    const endpoint = isYouTube ? '/summarize-youtube' : '/summarize-url';
    
    const data = await callAPI(endpoint, { url });
    
    removeTypingIndicator();
    addMessage('assistant', data.summary, { 
      source: isYouTube ? 'YouTube Video' : 'Web Page',
      followUpCount: 0
    });
    
    // Store context for follow-ups
    conversationState.currentContext = {
      summary: data.summary,
      url: url,
      type: isYouTube ? 'youtube' : 'webpage'
    };
    conversationState.followUpCount = 0;
    updateFollowUpCounter();
    
  } catch (error) {
    removeTypingIndicator();
    addMessage('error', `Failed to summarize: ${error.message}`);
  } finally {
    setProcessing(false);
  }
}

async function handleFollowUp(question) {
  if (conversationState.followUpCount >= MAX_FOLLOW_UPS) {
    addMessage('error', 'You\'ve reached the limit of 3 follow-up questions. Start a new summary to ask more.');
    return;
  }
  
  if (!conversationState.currentContext) {
    addMessage('error', 'Please summarize something first before asking follow-up questions.');
    return;
  }
  
  setProcessing(true);
  addMessage('user', question);
  addTypingIndicator();
  
  try {
    // Build conversation history for context
    const conversationHistory = conversationState.messages
      .filter(m => m.role === 'user' || m.role === 'assistant')
      .map(m => ({ role: m.role, content: m.content }));
    
    const data = await callAPI('/follow-up', {
      question,
      context: conversationState.currentContext.summary,
      history: conversationHistory
    });
    
    removeTypingIndicator();
    conversationState.followUpCount++;
    addMessage('assistant', data.answer, { 
      source: `Follow-up ${conversationState.followUpCount}/3`,
      followUpCount: conversationState.followUpCount
    });
    
    updateFollowUpCounter();
    
  } catch (error) {
    removeTypingIndicator();
    addMessage('error', `Follow-up failed: ${error.message}`);
  } finally {
    setProcessing(false);
  }
}

async function summarizeText(text) {
  setProcessing(true);
  addMessage('user', text.length > 200 ? text.substring(0, 200) + '...' : text, { source: 'Custom Text' });
  addTypingIndicator();
  
  try {
    const data = await callAPI('/summarize', { text });
    
    removeTypingIndicator();
    addMessage('assistant', data.summary, { 
      source: 'Custom Text',
      followUpCount: 0
    });
    
    // Store context for follow-ups
    conversationState.currentContext = {
      summary: data.summary,
      originalText: text,
      type: 'text'
    };
    conversationState.followUpCount = 0;
    updateFollowUpCounter();
    
  } catch (error) {
    removeTypingIndicator();
    addMessage('error', `Failed to summarize: ${error.message}`);
  } finally {
    setProcessing(false);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Event Handlers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

elements.btnPage.addEventListener('click', async () => {
  const url = await getCurrentUrl();
  if (!url) {
    addMessage('error', 'Could not get current page URL');
    return;
  }
  await summarizePage(url);
});

elements.btnYoutube.addEventListener('click', async () => {
  const url = await getCurrentUrl();
  if (!url.includes('youtube.com') && !url.includes('youtu.be')) {
    addMessage('error', 'Please navigate to a YouTube video first');
    return;
  }
  await summarizePage(url);
});

elements.sendBtn.addEventListener('click', async () => {
  const input = elements.userInput.value.trim();
  if (!input) return;
  
  elements.userInput.value = '';
  elements.userInput.style.height = '48px';
  
  // Determine if this is a follow-up or a new summarization
  if (conversationState.currentContext && input.length < 500) {
    // Likely a follow-up question
    await handleFollowUp(input);
  } else {
    // Treat as new text to summarize
    await summarizeText(input);
  }
});

elements.userInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    elements.sendBtn.click();
  }
});

// Auto-resize textarea
elements.userInput.addEventListener('input', () => {
  elements.userInput.style.height = '48px';
  elements.userInput.style.height = elements.userInput.scrollHeight + 'px';
});

elements.clearBtn.addEventListener('click', () => {
  if (confirm('Clear all messages and start a new conversation?')) {
    conversationState = {
      messages: [],
      followUpCount: 0,
      currentContext: null,
      isProcessing: false
    };
    elements.messagesContainer.innerHTML = '';
    elements.emptyState.style.display = 'flex';
    updateFollowUpCounter();
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Initialization
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

checkHealth();
updateFollowUpCounter();
```

**Why this architecture:**

**State Management:** Single `conversationState` object tracks messages, follow-up count, and current context. This enables intelligent routing (follow-up vs. new summary).

**Context Preservation:** After each summary, the result is stored in `currentContext`. Follow-up questions reference this context, enabling the LLM to answer questions about the summary.

**Smart Input Handling:** Input < 500 chars and context exists â†’ follow-up. Otherwise â†’ new summarization. This allows flexible usage.

**Visual Feedback:** Typing indicator, disabled buttons during processing, follow-up counter with color coding (green â†’ yellow â†’ red as limit approaches).

**Expected Result:** File created. Logic will execute when side panel opens.

---

# Phase 3: Update Server for Follow-ups

Your server already uses Google LLM. We need to add a `/follow-up` endpoint that maintains conversation context.

## Step 5: Add Follow-up Endpoint to Server

**Action:** Add this endpoint to your `server.py` (after existing endpoints):

```python
@app.route('/follow-up', methods=['POST'])
def follow_up_question():
    """
    Handle follow-up questions with conversation history.
    
    Expects:
    {
      "question": "What is X?",
      "context": "Original summary text...",
      "history": [
        {"role": "user", "content": "..."},
        {"role": "assistant", "content": "..."}
      ]
    }
    """
    data = request.get_json()
    question = data.get('question', '')
    context = data.get('context', '')
    history = data.get('history', [])
    
    if not question:
        return jsonify({'error': 'No question provided'}), 400
    
    if not context:
        return jsonify({'error': 'No context available. Summarize something first.'}), 400
    
    try:
        # Build the prompt for Google LLM
        # Format depends on your Google LLM setup (Gemini, PaLM, etc.)
        # This is a generic example - adapt to your specific API
        
        prompt = f"""You are a helpful assistant answering follow-up questions about a summary.

Original Summary:
{context}

Conversation History:
"""
        for msg in history[-4:]:  # Last 2 exchanges (4 messages)
            role_label = "User" if msg['role'] == 'user' else "Assistant"
            prompt += f"{role_label}: {msg['content']}\n"
        
        prompt += f"\nUser: {question}\nAssistant:"
        
        # Replace this with your actual Google LLM call
        # Example for Gemini API:
        # response = gemini_model.generate_content(prompt)
        # answer = response.text
        
        # For now, placeholder - replace with your LLM call
        answer = call_your_google_llm(prompt)
        
        return jsonify({'answer': answer})
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500


def call_your_google_llm(prompt):
    """
    Replace this function with your actual Google LLM API call.
    
    Example for Gemini:
    import google.generativeai as genai
    
    genai.configure(api_key=os.environ.get('GOOGLE_API_KEY'))
    model = genai.GenerativeModel('gemini-pro')
    response = model.generate_content(prompt)
    return response.text
    """
    # PLACEHOLDER - Replace with your actual implementation
    import os
    import google.generativeai as genai
    
    genai.configure(api_key=os.environ.get('GOOGLE_API_KEY'))
    model = genai.GenerativeModel('gemini-1.5-flash')
    response = model.generate_content(prompt)
    return response.text
```

**Why this matters:**

**Context Passing:** The original summary is sent with every follow-up. The LLM can reference it when answering questions.

**History Truncation:** Only the last 4 messages (2 exchanges) are sent to avoid token bloat. This keeps responses focused on recent conversation.

**Prompt Engineering:** The system prompt establishes the role ("answering follow-up questions about a summary") and provides structure.

**Error Handling:** Missing context returns a helpful error instead of crashing.

**Expected Result:** Endpoint added. Server restart required.

**Common Failure:** Import errors for Google LLM library.

**Fix:** Install the Google library you're using:
```bash
pip install google-generativeai  # For Gemini
# OR
pip install google-cloud-aiplatform  # For Vertex AI
```

---

# Phase 4: Enhance Server Endpoints

Let's improve your existing endpoints to return richer metadata.

## Step 6: Upgrade Existing Endpoints

**Action:** Modify the response format of your `/summarize`, `/summarize-url`, and `/summarize-youtube` endpoints to return additional metadata:

```python
# Example for /summarize endpoint
@app.route('/summarize', methods=['POST'])
def summarize_text():
    data = request.get_json()
    text = data.get('text', '')
    
    if not text or len(text.strip()) < 20:
        return jsonify({'error': 'Text must be at least 20 characters'}), 400
    
    try:
        # Your Google LLM call here
        summary = call_your_google_llm_for_summary(text)
        
        return jsonify({
            'summary': summary,
            'metadata': {
                'input_length': len(text),
                'word_count': len(text.split()),
                'timestamp': time.time()
            }
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500
```

Apply the same pattern to `/summarize-url` and `/summarize-youtube`.

**Why:** Metadata enables the frontend to display richer information (word count, processing time, etc.). This makes the tool feel more professional.

**Expected Result:** All endpoints return metadata alongside summaries.

---

# Phase 5: Testing the Upgraded Extension

## Step 7: Reload Extension and Test

**Action:**
1. Navigate to `chrome://extensions/`
2. Find "Professional Summarizer"
3. Click the **Reload** button (circular arrow icon)
4. Accept the new permissions prompt (sidePanel, storage)
5. Click the extension icon in the toolbar

**Expected Result:** Side panel opens on the right side of the browser window, displaying the professional interface.

**Common Failure:** "Could not load side panel"

**Fix:** Check browser console (F12 â†’ Console tab) for errors. Common issues:
- `sidepanel.html` not found â†’ verify filename is exact
- JavaScript error â†’ check syntax in `sidepanel.js`

---

## Step 8: Test Complete Workflow

**Action:** Perform this test sequence:

**Test A â€” Summarize Current Page**
1. Navigate to https://en.wikipedia.org/wiki/Machine_learning
2. Open side panel (click extension icon)
3. Click "Summarize This Page"
4. Verify summary appears in a chat bubble
5. Type: "What are the main applications?"
6. Click Send
7. Verify follow-up answer appears
8. Check counter shows "2 follow-up questions remaining"

**Test B â€” Follow-up Limit**
1. Ask a second follow-up question
2. Ask a third follow-up question
3. Verify counter turns red and says "Follow-up limit reached"
4. Try to ask a 4th question
5. Verify error message appears

**Test C â€” New Summary Resets Counter**
1. Click "Summarize This Page" again (different page)
2. Verify counter resets to "3 follow-up questions remaining"

**Test D â€” YouTube Video**
1. Navigate to a YouTube video with captions
2. Click "Summarize Video"
3. Ask follow-up questions about the video content

**Test E â€” Custom Text**
1. Paste a long text into the input box
2. Click Send
3. Verify it summarizes (not treated as follow-up)

**Expected Result:** All tests pass. UI is smooth, errors are clear, follow-up logic works correctly.

**Common Failure:** Follow-ups not working.

**Fix:** Check browser console for `/follow-up` endpoint errors. Verify your Google LLM credentials are set correctly. Test the endpoint directly with curl:
```bash
curl -X POST http://127.0.0.1:5000/follow-up \
  -H "Content-Type: application/json" \
  -d '{"question":"What is X?","context":"Summary text here","history":[]}'
```

---

# Phase 6: Professional Enhancements

Now we improve the system to be production-quality.

## Step 9: Add Conversation Persistence

**Action:** Add storage persistence to `sidepanel.js`. Insert this code near the top, after the `conversationState` declaration:

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Storage Persistence
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const STORAGE_KEY = 'summarizer_conversation';

async function loadConversation() {
  const result = await chrome.storage.local.get(STORAGE_KEY);
  if (result[STORAGE_KEY]) {
    conversationState = result[STORAGE_KEY];
    
    // Restore messages to UI
    conversationState.messages.forEach(msg => {
      addMessageWithoutSaving(msg.role, msg.content, msg.metadata);
    });
    
    updateFollowUpCounter();
  }
}

async function saveConversation() {
  await chrome.storage.local.set({ [STORAGE_KEY]: conversationState });
}

// Modified addMessage to trigger save
function addMessageWithoutSaving(role, content, metadata = {}) {
  // (Same logic as current addMessage, but doesn't call saveConversation)
  // ... existing code ...
}

function addMessage(role, content, metadata = {}) {
  addMessageWithoutSaving(role, content, metadata);
  saveConversation();
}

// Load conversation on startup
loadConversation();
```

**Why:** Conversations persist across browser restarts. Users can close the side panel and reopen it without losing context. This is critical for professional tools.

**Expected Result:** After adding messages and reloading the extension, messages remain visible.

---

## Step 10: Add Export Conversation Feature

**Action:** Add this button to `sidepanel.html` in the status bar (next to Clear button):

```html
<button class="clear-btn" id="exportBtn">Export Chat</button>
```

Add this handler to `sidepanel.js`:

```javascript
elements.exportBtn = document.getElementById('exportBtn');

elements.exportBtn.addEventListener('click', () => {
  const exportData = {
    timestamp: new Date().toISOString(),
    messages: conversationState.messages.map(m => ({
      role: m.role,
      content: m.content,
      metadata: m.metadata
    }))
  };
  
  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `summarizer-chat-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
});
```

**Why:** Users can save important summaries and conversations. Exported JSON can be imported into other tools or archived. This is a standard feature in professional AI tools.

**Expected Result:** Clicking "Export Chat" downloads a JSON file with all messages.

---

## Step 11: Add Summary Quality Indicators

**Action:** Modify the server's `/summarize*` endpoints to return quality metrics:

```python
def call_your_google_llm_for_summary(text):
    """Add quality scoring to summary generation"""
    summary = # ... your LLM call
    
    # Calculate quality metrics
    compression_ratio = len(summary) / len(text)
    
    return {
        'summary': summary,
        'quality_metrics': {
            'compression_ratio': round(compression_ratio, 2),
            'original_length': len(text),
            'summary_length': len(summary),
            'model': 'gemini-1.5-flash'  # or your model name
        }
    }
```

Update the frontend to display these metrics in the summary meta section.

**Why:** Quality indicators build trust. Users can see how much the text was compressed and which model generated the summary. This transparency is critical for professional tools.

**Expected Result:** Summaries show metrics like "85% compression" and model name.

---

## Step 12: Add Keyboard Shortcuts

**Action:** Add to `sidepanel.js`:

```javascript
// Global keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // Ctrl/Cmd + K: Focus input
  if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
    e.preventDefault();
    elements.userInput.focus();
  }
  
  // Ctrl/Cmd + Shift + C: Clear conversation
  if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'C') {
    e.preventDefault();
    elements.clearBtn.click();
  }
  
  // Ctrl/Cmd + Shift + S: Summarize current page
  if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'S') {
    e.preventDefault();
    elements.btnPage.click();
  }
});
```

Add a help tooltip showing these shortcuts near the header.

**Why:** Power users rely on keyboard shortcuts. This makes the tool significantly faster for frequent use. Standard shortcuts (Cmd+K for search) leverage learned behavior.

**Expected Result:** Keyboard shortcuts work as described.

---

# Phase 7: Advanced Professional Features

## Step 13: Add Summary Templates

**Action:** Create preset prompt templates for different use cases. Add to `sidepanel.html`:

```html
<div class="template-selector">
  <select id="templateSelect">
    <option value="default">Standard Summary</option>
    <option value="executive">Executive Summary</option>
    <option value="technical">Technical Deep-Dive</option>
    <option value="eli5">Explain Like I'm 5</option>
    <option value="bullets">Key Points (Bullets)</option>
  </select>
</div>
```

Add template logic to `sidepanel.js`:

```javascript
const TEMPLATES = {
  default: "Provide a clear, concise summary of the main points.",
  executive: "Provide an executive summary focusing on key decisions, outcomes, and business impact. Maximum 3 paragraphs.",
  technical: "Provide a detailed technical summary including methodologies, technologies, and implementation details.",
  eli5: "Explain this in simple terms that a 5-year-old could understand. Use analogies and avoid jargon.",
  bullets: "Summarize as a bulleted list of the 5-7 most important points."
};

async function summarizeWithTemplate(text, template) {
  const instruction = TEMPLATES[template];
  const enhancedPrompt = `${instruction}\n\nText to summarize:\n${text}`;
  
  // Call your LLM with the enhanced prompt
  // ...
}
```

**Why:** Different contexts need different summary styles. Executives want brevity and business impact. Technical users want details. Templates make the tool adaptable to various professional needs.

**Expected Result:** Users can select summary style before summarizing.

---

## Step 14: Add Copy to Clipboard

**Action:** Add copy button to each assistant message. Update message HTML in `sidepanel.js`:

```javascript
function addMessage(role, content, metadata = {}) {
  // ... existing code ...
  
  if (role === 'assistant') {
    const copyBtn = document.createElement('button');
    copyBtn.className = 'copy-btn';
    copyBtn.innerHTML = 'ğŸ“‹ Copy';
    copyBtn.onclick = () => {
      navigator.clipboard.writeText(content);
      copyBtn.innerHTML = 'âœ… Copied!';
      setTimeout(() => {
        copyBtn.innerHTML = 'ğŸ“‹ Copy';
      }, 2000);
    };
    message.querySelector('.message-content').appendChild(copyBtn);
  }
  
  // ... rest of code ...
}
```

Add CSS for copy button:

```css
.copy-btn {
  margin-top: 12px;
  padding: 6px 12px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text-secondary);
  font-size: 11px;
  cursor: pointer;
  transition: all 0.2s;
  display: inline-block;
}

.copy-btn:hover {
  background: var(--accent);
  color: var(--text-primary);
  border-color: var(--accent);
}
```

**Why:** Users frequently need to paste summaries into documents, emails, or notes. One-click copying is essential for productivity tools.

**Expected Result:** Each summary has a copy button. Clicking it copies text to clipboard and shows confirmation.

---

## Step 15: Add Source Citation

**Action:** For URL summaries, add automatic citation generation:

```python
@app.route('/summarize-url', methods=['POST'])
def summarize_url():
    # ... existing code ...
    
    # After getting summary
    citation = generate_citation(url, summary)
    
    return jsonify({
        'summary': summary,
        'citation': citation,
        'metadata': {...}
    })

def generate_citation(url, summary):
    """Generate MLA-style citation"""
    from urllib.parse import urlparse
    from datetime import datetime
    
    domain = urlparse(url).netloc
    date = datetime.now().strftime("%d %b. %Y")
    
    return f'"{summary[:50]}..." {domain}, {date}. Web.'
```

Display citation in the frontend below summaries.

**Why:** Academic and professional users need proper citations. Auto-generating them saves time and ensures consistency. This elevates the tool from consumer to professional-grade.

**Expected Result:** URL summaries include a copyable citation.

---

# Phase 8: Final Polish

## Step 16: Add Loading States for Long Operations

**Action:** Replace simple typing indicator with progress stages:

```javascript
function addProgressIndicator(stage) {
  const stages = {
    fetching: 'Fetching content...',
    parsing: 'Extracting text...',
    summarizing: 'Generating summary...',
    finalizing: 'Finalizing...'
  };
  
  const existing = document.getElementById('progressIndicator');
  if (existing) {
    existing.querySelector('.progress-text').textContent = stages[stage];
  } else {
    const indicator = document.createElement('div');
    indicator.id = 'progressIndicator';
    indicator.className = 'message assistant';
    indicator.innerHTML = `
      <div class="message-content">
        <div class="progress-indicator">
          <div class="progress-spinner"></div>
          <div class="progress-text">${stages[stage]}</div>
        </div>
      </div>
    `;
    elements.messagesContainer.appendChild(indicator);
  }
}
```

Add CSS for spinner:

```css
.progress-indicator {
  display: flex;
  align-items: center;
  gap: 12px;
}

.progress-spinner {
  width: 20px;
  height: 20px;
  border: 3px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
```

**Why:** Long operations (YouTube extraction can take 10+ seconds) need reassurance. Stage-based progress indicators prevent user frustration.

**Expected Result:** Users see what stage processing is at during long operations.

---

## Step 17: Add Error Recovery

**Action:** Add retry logic to API calls:

```javascript
async function callAPIWithRetry(endpoint, payload, maxRetries = 2) {
  for (let i = 0; i <= maxRetries; i++) {
    try {
      return await callAPI(endpoint, payload);
    } catch (error) {
      if (i === maxRetries) throw error;
      
      // Exponential backoff
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
    }
  }
}
```

**Why:** Network hiccups shouldn't require manual retries. Automatic retry with backoff handles transient failures gracefully.

**Expected Result:** Temporary network failures recover automatically.

---

## Step 18: Add Analytics (Optional)

**Action:** Track usage metrics locally:

```javascript
async function trackUsage(action, metadata = {}) {
  const stats = await chrome.storage.local.get('usage_stats') || { usage_stats: {} };
  const today = new Date().toISOString().split('T')[0];
  
  if (!stats.usage_stats[today]) {
    stats.usage_stats[today] = { summaries: 0, follow_ups: 0, errors: 0 };
  }
  
  stats.usage_stats[today][action] = (stats.usage_stats[today][action] || 0) + 1;
  
  await chrome.storage.local.set(stats);
}

// Call in appropriate places:
// trackUsage('summaries') after successful summary
// trackUsage('follow_ups') after follow-up
// trackUsage('errors') on errors
```

Add a stats viewer in the UI showing daily usage.

**Why:** Users want to know how much they're using the tool. This data can inform future improvements. Privacy-first (all data local).

**Expected Result:** Stats section shows usage over time.

---

# Summary of Improvements

You've transformed a basic popup into a professional tool with:

âœ… **Full-height side panel** with persistent state
âœ… **Conversational interface** with up to 3 follow-ups per summary
âœ… **Professional UI** with custom animations, gradients, and typography
âœ… **Context-aware routing** (follow-up vs. new summary)
âœ… **Conversation persistence** across browser sessions
âœ… **Export functionality** for archiving conversations
âœ… **Quality metrics** for transparency
âœ… **Keyboard shortcuts** for power users
âœ… **Summary templates** for different use cases
âœ… **One-click copying** to clipboard
âœ… **Auto-citations** for academic use
âœ… **Progress indicators** for long operations
âœ… **Error recovery** with automatic retries
âœ… **Usage analytics** (privacy-first)

---

# Next-Level Enhancements (Future)

**Phase 9 â€” Advanced Features:**
- Multi-language support (detect language, summarize in original or translate)
- Batch processing (summarize multiple tabs at once)
- Custom model selection (switch between Gemini models)
- Voice input for follow-up questions
- Markdown/PDF export of conversations
- Integration with note-taking apps (Notion, Obsidian)
- Collaborative sharing (share summaries via link)
- Browser action context menus (right-click â†’ summarize selected text)

**Phase 10 â€” Enterprise Features:**
- Team workspaces with shared summaries
- API key management UI (no code changes for new keys)
- Rate limiting with usage quotas
- Summary approval workflows
- Audit logs for compliance
- SSO integration
- Custom branding

The foundation you've built supports all these future enhancements without major refactoring.
